
/*

Concatenating Json Objects

Author: @mugo_gocho <mugo@forfuture.co.ke>
License: MIT
 */


/*

Notes:

1. A result object is reused in order to avoid creating many arrays
    then have to join them together. This makes it faster.
2. Two alternative algorithms can be used to concatenate stringified
    JSON objects:
    i) Concatenate, use RegExp and Parse (algorithm 1)
        - concatenate the stringified json objects
        - use RegExp to try make the string a valid
            stringified json object
        - parse the result string into an object
    ii) Parse and Join
        - parse each string into a json object
        - then loop through each of the objects assigning its
            keys and values to a result object
    Performance:
        - I used jsperf.com to run performance test.
        - algorithm 1 was faster than algorithm 2
        - See test suite at http://jsperf.com/json-concat/
    Discussion/Conclusion:
        - Although algorithm 1 is faster, we use both. Reason
            is that algorithm 2 is forgiving by letting us ignore
            strings that can not be parsed into objects. algorithm
            1 makes it hard to rescue the situation if the final
            string can not be parsed.
        We use algorithm 1 at first. If it fails to realize an object,
            we turn to algorithm 2 to scavange any objects it
            can find.
 */

(function() {
  "use strict";
  var concat, exports, fs, path, readContent;

  fs = require("fs");

  path = require("path");


  /*
  Concatenates content from all JSON files encountered
  This is recursive and will go into directories looking for files with
  the extension ".json"
  
  @param <filepath> - {String} path to file/directory
  @param <resultObject> - {Object} object that will hold the result (see note 1)
  @param <callback> - {Function} callback(content, contentArray)
   */

  readContent = function(filepath, resultObject, callback) {
    var encounteredFile, filesEncountered, filesProcessed, processedFile, read;
    filesEncountered = 0;
    filesProcessed = 0;
    if (resultObject.contentString == null) {
      resultObject.contentString = "";
    }
    if (resultObject.contentArray == null) {
      resultObject.contentArray = [];
    }
    encounteredFile = function() {
      return filesEncountered++;
    };
    processedFile = function(fileContent) {
      if (fileContent == null) {
        fileContent = "";
      }
      resultObject.contentString += fileContent;
      if (fileContent) {
        resultObject.contentArray.push(fileContent);
      }
      filesProcessed++;
      if (filesProcessed === filesEncountered) {
        return callback(resultObject);
      }
    };
    if (typeof filepath === "object") {
      resultObject.contentString += JSON.stringify(filepath);
      resultObject.contentArray.push(filepath);
      return callback(resultObject);
    }
    read = function(filepath) {
      encounteredFile();
      return fs.stat(filepath, function(err, stats) {
        if (err) {
          return processedFile(null);
        }
        if (stats.isDirectory()) {
          return fs.readdir(filepath, function(err, files) {
            var file, i, len;
            if (err) {
              return processedFile(null);
            }
            for (i = 0, len = files.length; i < len; i++) {
              file = files[i];
              read(path.join(filepath, file));
            }
            return processedFile(null);
          });
        } else if (stats.isFile()) {
          if (path.extname(filepath) === ".json") {
            return fs.readFile(filepath, {
              encoding: "utf8"
            }, function(err, content) {
              if (err) {
                return processedFile(null);
              }
              return processedFile(content);
            });
          } else {
            return processedFile(null);
          }
        }
      });
    };
    return read(filepath);
  };


  /*
  Creates a new JSON object from a string of concatenated stringified
  JSON objects.
  
  @param <string> - {String} string of json
  @param <callback> - {Function} callback(validString, validObject)
   */

  concat = function(contentString, contentArray, callback) {
    var content, err, error, error1, i, key, len, result, string, tmp, value;
    if (contentString === "") {
      return callback("{}", {});
    }
    string = contentString.replace(/^({\s*})*|({\s*})*$/g, "");
    string = string.replace(/}\s*({\s*})*\s*{/g, ",");
    string = string.replace(/}\s*{/g, ",");
    try {
      return callback(string, JSON.parse(string));
    } catch (error) {
      err = error;
      result = {};
      for (i = 0, len = contentArray.length; i < len; i++) {
        content = contentArray[i];
        try {
          tmp = JSON.parse(content);
          for (key in tmp) {
            value = tmp[key];
            result[key] = value;
          }
        } catch (error1) {
          err = error1;
        }
      }
      return callback(JSON.stringify(result), result);
    }
  };


  /*
  exported function
   */

  exports = module.exports = function(userOptions, callback) {
    var index, options, result, start;
    options = {
      src: userOptions.src || process.cwd(),
      dest: userOptions.dest || "./concat.json",
      middleware: userOptions.middleware || false
    };
    if (userOptions.dest === null) {
      options.dest = null;
    }
    if (typeof options.src === "string") {
      options.src = [options.src];
    }
    result = {};
    index = 0;
    start = function(callback) {
      var next;
      next = function() {
        return readContent(options.src[index], result, function() {
          ++index;
          if (index < options.src.length) {
            return next();
          }
          return concat(result.contentString, result.contentArray, function(string, obj) {
            if (options.dest) {
              return fs.writeFile(options.dest, string, function(err) {
                return callback(err, obj);
              });
            } else {
              return callback(null, obj);
            }
          });
        });
      };
      return next();
    };
    if (options.middleware) {
      return function(req, res, next) {
        return start(function(err, obj) {
          return next(obj || {});
        });
      };
    } else {
      return start(callback);
    }
  };

}).call(this);
